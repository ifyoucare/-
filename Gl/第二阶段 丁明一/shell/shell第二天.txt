使用expr、$[ ]、let等整数运算工具：定义变量X=1234，然后计算X与78的四则运算及求模结果
expr运算符号两边必须有空格，*号需要单引号屏蔽或者\*
\只能屏蔽接下来的一个特殊字符或变量

%取余数,也叫做求模运算
2**3 表示2的三次幂
$[] *不需要转义，运算符前后不需要空格，变量直接输入就行$相当于提出来了

let命令可以直接对变量值做运算再保存新的值。因此变量X=1234，在执行let运算后的值会变更；另外，let运算操作并不显示结果，但是可以结合echo命令来查看    i++   --->   i=i+1
       i--     --->   i=i-1
       i+=8  --->  i=i+8
       i-=8   --->  i=i-8
       i*=8   --->  i=i*8
       i/=8   --->  i=i/8
       i%=8  --->  i=i%8
使用bc实现小数运算操作：以交互方式计算12.34与56.78的四则运算结果，另外再以非交互方式重复上述计算，最多显示4位小数  scale=2表示小数点保留两位
[root@svr7 ~]# echo "1.2+55" | bc
56.2
[root@svr7 ~]# echo "scale=1;2/10" | bc
.2
[root@svr7 ~]# echo "scale=1;12/10" | bc
1.2

        test a == b       [ a == b ]
使用“test 表达式”或者[ 表达式 ]都可以，表达式两边至少要留一个空格。
条件测试操作本身不显示出任何信息。测试的条件是否成立主要体现在命令执行后的返回状态（即 $?），所以可以在测试后查看变量$?的值来做出判断，或者结合&&、||等逻辑操作显示出结果（或作其他操作） 

字符串测试
一行执行多条命令的情况
# A && B                        //仅当A命令执行成功，才执行B命令
# A || B                        //仅当A命令执行失败，才执行B命令
# A ;  B                        //执行A命令后执行B命令，两者没有逻辑关系
# A && B || C                   //思考？

[ -z $NB ]  判断字符串是否为空
还有一个-n可以测试变量是否不为空（相当于! -z）

/dev下有c开头字符设备按输入顺序输出（键盘鼠标等）、b开头块设备（硬盘）
还有p设备，piple管道

ping   -i0.1 每0.1sping一次  -w1  ping的过程只等1s

ps aux 可以查看所有进程
[root@room9pc01 ~]# ps aux | grep asdf
root     10785  0.0  0.0 112676   984 pts/2    S+   17:28   0:00 grep --color=auto asdf
grep 会把自己找到
[root@room9pc01 ~]# ps aux | grep asdf | grep -v grep
[root@room9pc01 ~]# 

if  可以直接加命令
if ping -c 2 192.168.4.5 &> /dev/null ;then
  echo "up"
else
  echo "down"
fi










